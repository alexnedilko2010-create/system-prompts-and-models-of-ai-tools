"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PullFeed = exports.OracleResponse = void 0;
exports.toFeedValue = toFeedValue;
const AnchorUtils_js_1 = require("../anchor-utils/AnchorUtils.js");
const constants_js_1 = require("../constants.js");
const InstructionUtils_js_1 = require("../instruction-utils/InstructionUtils.js");
const Secp256k1InstructionUtils_js_1 = require("../instruction-utils/Secp256k1InstructionUtils.js");
const recentSlothashes_js_1 = require("../sysvars/recentSlothashes.js");
const spl = __importStar(require("../utils/index.js"));
const index_js_1 = require("../utils/index.js");
const lookupTable_js_1 = require("../utils/lookupTable.js");
const oracle_js_1 = require("./oracle.js");
const queue_js_1 = require("./queue.js");
const state_js_1 = require("./state.js");
const anchor_30_1 = require("@coral-xyz/anchor-30");
const common_1 = require("@switchboard-xyz/common");
const buffer_1 = require("buffer");
class OracleResponse {
    constructor(oracle, value, error) {
        this.oracle = oracle;
        this.value = value;
        this.error = error;
    }
    shortError() {
        if (this.error === '[]') {
            return undefined;
        }
        const parts = this.error.split('\n');
        return parts[0];
    }
}
exports.OracleResponse = OracleResponse;
function padStringWithNullBytes(input, desiredLength = 32) {
    const nullByte = '\0';
    while (input.length < desiredLength) {
        input += nullByte;
    }
    return input;
}
function toFeedValue(submissions, onlyAfter) {
    let values = submissions.filter(x => x.slot.gt(onlyAfter));
    if (values.length === 0) {
        return null;
    }
    values = values.sort((x, y) => (x.value.lt(y.value) ? -1 : 1));
    return values[Math.floor(values.length / 2)];
}
function getIsSolana(chain) {
    return chain === undefined || chain === 'solana';
}
function getIsMainnet(network) {
    return network === 'mainnet' || network === 'mainnet-beta';
}
/**
 *  Checks if the pull feed account needs to be initialized.
 *
 *  @param connection The connection to use.
 *  @param programId The program ID.
 *  @param pubkey The public key of the pull feed account.
 *  @returns A promise that resolves to a boolean indicating if the account needs to be initialized.
 */
function checkNeedsInit(connection, programId, pubkey) {
    return __awaiter(this, void 0, void 0, function* () {
        const accountInfo = yield connection.getAccountInfo(pubkey);
        if (accountInfo === null)
            return true;
        const owner = accountInfo.owner;
        if (!owner.equals(programId))
            return true;
        return false;
    });
}
/**
 *  Abstraction around the Switchboard-On-Demand Feed account
 *
 *  This account is used to store the feed data and the oracle responses
 *  for a given feed.
 */
class PullFeed {
    /**
     * Constructs a `PullFeed` instance.
     *
     * @param program - The Anchor program instance.
     * @param pubkey - The public key of the pull feed account.
     */
    constructor(program, pubkey) {
        this.program = program;
        this.gatewayUrl = '';
        this.pubkey = new anchor_30_1.web3.PublicKey(pubkey);
        this.configs = null;
        this.jobs = null;
    }
    static generate(program) {
        const keypair = anchor_30_1.web3.Keypair.generate();
        const feed = new PullFeed(program, keypair.publicKey);
        return [feed, keypair];
    }
    lookupTableKey(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const lutSigner = (0, lookupTable_js_1.getLutSigner)(this.program.programId, this.pubkey);
            const { lutSlot } = data !== null && data !== void 0 ? data : (yield this.loadData());
            return (0, lookupTable_js_1.getLutKey)(lutSigner, lutSlot);
        });
    }
    /**
     * Prefetch all lookup tables needed for the feed and queue.
     * @returns A promise that resolves to an array of lookup tables.
     * @throws if the lookup tables cannot be loaded.
     */
    preHeatLuts() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.loadData();
            const queue = new queue_js_1.Queue(this.program, data.queue);
            const oracleKeys = yield queue.fetchOracleKeys();
            const oracles = oracleKeys.map(k => new oracle_js_1.Oracle(this.program, k));
            const lutOwners = [...oracles, queue, this];
            const luts = yield (0, index_js_1.loadLookupTables)(lutOwners);
            return luts;
        });
    }
    static initTx(program, params) {
        return __awaiter(this, void 0, void 0, function* () {
            const [pullFeed, keypair] = PullFeed.generate(program);
            const ix = yield pullFeed.initIx(params);
            const tx = yield InstructionUtils_js_1.InstructionUtils.asV0TxWithComputeIxs({
                connection: program.provider.connection,
                ixs: [ix],
            });
            tx.sign([keypair]);
            return [pullFeed, tx];
        });
    }
    static getPayer(program, payer) {
        var _a;
        return (_a = payer !== null && payer !== void 0 ? payer : program.provider.publicKey) !== null && _a !== void 0 ? _a : anchor_30_1.web3.PublicKey.default;
    }
    getPayer(payer) {
        return PullFeed.getPayer(this.program, payer);
    }
    /**
     *  Calls to initialize a pull feed account and to update the configuration account need to
     *  compute the feed hash for the account (if one is not specified).
     */
    static feedHashFromParams(params) {
        const hash = (() => {
            var _a;
            if (params.feedHash) {
                // If the feed hash is provided, use it.
                return params.feedHash;
            }
            else if ((_a = params.jobs) === null || _a === void 0 ? void 0 : _a.length) {
                // Else if jobs are provided, compute the feed hash from the queue and jobs.
                return common_1.FeedHash.compute(params.queue.toBuffer(), params.jobs);
            }
            throw new Error('Either "feedHash" or "jobs" must be provided.');
        })();
        if (hash.byteLength === 32)
            return hash;
        throw new Error('Feed hash must be 32 bytes');
    }
    /**
     * Initializes a pull feed account.
     *
     * @param {Program} program - The Anchor program instance.
     * @param {PublicKey} queue - The queue account public key.
     * @param {Array<IOracleJob>} jobs - The oracle jobs to execute.
     * @param {number} maxVariance - The maximum variance allowed for the feed.
     * @param {number} minResponses - The minimum number of job responses required.
     * @param {number} minSampleSize - The minimum number of samples required for setting feed value.
     * @param {number} maxStaleness - The maximum number of slots that can pass before a feed value is considered stale.
     * @returns {Promise<web3.TransactionInstruction>} A promise that resolves to the transaction instruction.
     */
    initIx(params) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const program = this.program;
            const feedHash = PullFeed.feedHashFromParams({
                queue: params.queue,
                feedHash: 'feedHash' in params ? params.feedHash : undefined,
                jobs: 'jobs' in params ? params.jobs : undefined,
            });
            const payerPublicKey = this.getPayer(params.payer);
            const maxVariance = Math.floor(params.maxVariance * 1e9);
            const lutSigner = (0, lookupTable_js_1.getLutSigner)(program.programId, this.pubkey);
            const recentSlot = yield program.provider.connection.getSlot('finalized');
            const lutKey = (0, lookupTable_js_1.getLutKey)(lutSigner, recentSlot);
            const ix = program.instruction.pullFeedInit({
                feedHash: feedHash,
                maxVariance: new anchor_30_1.BN(maxVariance),
                minResponses: params.minResponses,
                name: buffer_1.Buffer.from(padStringWithNullBytes(params.name)),
                recentSlot: new anchor_30_1.BN(recentSlot),
                ipfsHash: new Uint8Array(32), // Deprecated.
                minSampleSize: params.minSampleSize,
                maxStaleness: params.maxStaleness,
                permitWriteByAuthority: (_a = params.permitWriteByAuthority) !== null && _a !== void 0 ? _a : null,
            }, {
                accounts: {
                    pullFeed: this.pubkey,
                    queue: params.queue,
                    authority: payerPublicKey,
                    payer: payerPublicKey,
                    systemProgram: anchor_30_1.web3.SystemProgram.programId,
                    programState: state_js_1.State.keyFromSeed(program),
                    rewardEscrow: spl.getAssociatedTokenAddressSync(constants_js_1.SOL_NATIVE_MINT, this.pubkey),
                    tokenProgram: constants_js_1.SPL_TOKEN_PROGRAM_ID,
                    associatedTokenProgram: constants_js_1.SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,
                    wrappedSolMint: constants_js_1.SOL_NATIVE_MINT,
                    lutSigner: lutSigner,
                    lut: lutKey,
                    addressLookupTableProgram: anchor_30_1.web3.AddressLookupTableProgram.programId,
                },
            });
            return ix;
        });
    }
    closeIx(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const payerPublicKey = this.getPayer(params.payer);
            const lutSigner = (0, lookupTable_js_1.getLutSigner)(this.program.programId, this.pubkey);
            const data = yield this.loadData();
            const lutKey = (0, lookupTable_js_1.getLutKey)(lutSigner, data.lutSlot);
            const ix = this.program.instruction.pullFeedClose({}, {
                accounts: {
                    pullFeed: this.pubkey,
                    authority: data.authority,
                    payer: payerPublicKey,
                    rewardEscrow: spl.getAssociatedTokenAddressSync(constants_js_1.SOL_NATIVE_MINT, this.pubkey),
                    lutSigner: lutSigner,
                    lut: lutKey,
                    state: state_js_1.State.keyFromSeed(this.program),
                    tokenProgram: constants_js_1.SPL_TOKEN_PROGRAM_ID,
                    associatedTokenProgram: constants_js_1.SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,
                    systemProgram: anchor_30_1.web3.SystemProgram.programId,
                    addressLookupTableProgram: anchor_30_1.web3.AddressLookupTableProgram.programId,
                },
            });
            return ix;
        });
    }
    /**
     * Set configurations for the feed.
     *
     * @param params
     * @param params.feedHash - The hash of the feed as a `Uint8Array` or hexadecimal `string`. Only results signed with this hash will be accepted.
     * @param params.authority - The authority of the feed.
     * @param params.maxVariance - The maximum variance allowed for the feed.
     * @param params.minResponses - The minimum number of responses required.
     * @param params.minSampleSize - The minimum number of samples required for setting feed value.
     * @param params.maxStaleness - The maximum number of slots that can pass before a feed value is considered stale.
     * @returns A promise that resolves to the transaction instruction to set feed configs.
     */
    setConfigsIx(params) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e;
            const data = yield this.loadData();
            const name = params.name !== undefined
                ? buffer_1.Buffer.from(padStringWithNullBytes(params.name))
                : null;
            const feedHash = params.feedHash || params.jobs
                ? PullFeed.feedHashFromParams({
                    queue: data.queue,
                    feedHash: params.feedHash,
                    jobs: params.jobs,
                })
                : null;
            const ix = this.program.instruction.pullFeedSetConfigs({
                name: name,
                feedHash: feedHash,
                authority: (_a = params.authority) !== null && _a !== void 0 ? _a : null,
                maxVariance: params.maxVariance !== undefined
                    ? new anchor_30_1.BN(Math.floor(params.maxVariance * 1e9))
                    : null,
                minResponses: (_b = params.minResponses) !== null && _b !== void 0 ? _b : null,
                minSampleSize: (_c = params.minSampleSize) !== null && _c !== void 0 ? _c : null,
                maxStaleness: (_d = params.maxStaleness) !== null && _d !== void 0 ? _d : null,
                permitWriteByAuthority: (_e = params.permitWriteByAuthority) !== null && _e !== void 0 ? _e : null,
                ipfsHash: null, // Deprecated.
            }, {
                accounts: {
                    pullFeed: this.pubkey,
                    authority: data.authority,
                },
            });
            return ix;
        });
    }
    /**
     * Fetch updates for the feed.
     *
     * @param {object} params_ - The parameters object.
     * @param {string} [params_.gateway] - Optionally specify the gateway to use. If not specified, the gateway is automatically fetched.
     * @param {number} [params_.numSignatures] - Number of signatures to fetch.
     * @param {FeedRequest} [params_.feedConfigs] - Optionally specify the feed configs. If not specified, the feed configs are automatically fetched.
     * @param {IOracleJob[]} [params_.jobs] - An array of `IOracleJob` representing the jobs to be executed.
     * @param {CrossbarClient} [params_.crossbarClient] - Optionally specify the CrossbarClient to use.
     * @param {Array<[BN, string]>} [recentSlothashes] - An optional array of recent slothashes as `[BN, string]` tuples.
     * @param {FeedEvalResponse[]} [priceSignatures] - An optional array of `FeedEvalResponse` representing the price signatures.
     * @param {boolean} [debug=false] - A boolean flag to enable or disable debug mode. Defaults to `false`.
     * @returns {Promise<[TransactionInstruction | undefined, OracleResponse[], number, any[]]>} A promise that resolves to a tuple containing:
     * - The transaction instruction to fetch updates, or `undefined` if not applicable.
     * - An array of `OracleResponse` objects.
     * - A number representing the successful responses.
     * - An array containing usable lookup tables.
     */
    fetchUpdateIx(params_1) {
        return __awaiter(this, arguments, void 0, function* (params, debug = false, payer) {
            var _a;
            const feedConfigs = yield this.loadConfigs();
            const numSignatures = (_a = params.numSignatures) !== null && _a !== void 0 ? _a : feedConfigs.minSampleSize + Math.ceil(feedConfigs.minSampleSize / 3);
            return yield PullFeed.fetchUpdateIx(
            /* params= */ {
                pullFeed: this,
                gateway: params.gateway,
                chain: params.chain,
                network: params.network,
                numSignatures: numSignatures,
                crossbarClient: params.crossbarClient,
                solanaRpcUrl: params.solanaRpcUrl,
                recentSlothashes: params.recentSlothashes,
            }, debug, payer);
        });
    }
    /**
     * Loads the feed configurations (if not already cached) for this {@linkcode PullFeed} account from on chain.
     * @returns A promise that resolves to the feed configurations.
     * @throws if the feed account does not exist.
     */
    loadConfigs(force) {
        return __awaiter(this, void 0, void 0, function* () {
            // If forcing a reload or configs are not already cached, load the configs.
            if (force || !this.configs) {
                this.configs = yield (() => __awaiter(this, void 0, void 0, function* () {
                    const data = yield this.loadData();
                    const maxVariance = data.maxVariance.toNumber() / 1e9;
                    return {
                        queue: data.queue,
                        maxVariance: maxVariance,
                        minResponses: data.minResponses,
                        feedHash: buffer_1.Buffer.from(data.feedHash),
                        minSampleSize: data.minSampleSize,
                    };
                }))();
            }
            return this.configs;
        });
    }
    /**
     * Fetches updates for a feed, returning instructions that must be executed in order at the front
     * of the transaction.
     *
     * @param program - The Anchor program instance
     * @param params - The parameters object
     * @param params.feed - PullFeed address to fetch updates for
     * @param params.gateway - Optional gateway URL to use for fetching updates
     * @param params.chain - Optional chain identifier (defaults to "solana")
     * @param params.network - Optional network identifier ("mainnet", "mainnet-beta", "testnet", "devnet")
     * @param params.numSignatures - Number of signatures to fetch
     * @param params.crossbarClient - Optional CrossbarClient instance to use
     * @param recentSlothashes - Optional array of recent slothashes as [BN, string] tuples
     * @param debug - Enable debug logging (default: false)
     * @param payer - Optional transaction payer public key
     * @returns Promise resolving to:
     * - instructions: Array of instructions that must be executed in order:
     *   [0] = secp256k1 program verification instruction
     *   [1] = feed update instruction
     * - oracleResponses: Array of responses from oracles
     * - numSuccesses: Number of successful responses
     * - luts: Array of AddressLookupTableAccount to include
     * - failures: Array of errors that occurred during the fetch
     */
    static fetchUpdateIx(params, debug, payer) {
        return __awaiter(this, void 0, void 0, function* () {
            const isSolana = getIsSolana(params.chain);
            const { queue } = yield params.pullFeed.loadConfigs(false);
            // SVM chains that arent solana should use the older `fetchUpdateIxSvm` function
            if (!isSolana) {
                return this.fetchUpdateIxSvm(params, debug, payer);
            }
            // Fetch the update using the `fetchUpdateManyIx` function
            const [ixns, luts, report] = yield PullFeed.fetchUpdateManyIx(params.pullFeed.program, {
                feeds: [params.pullFeed.pubkey],
                chain: params.chain,
                network: params.network,
                gateway: params.gateway,
                recentSlothashes: params.recentSlothashes,
                numSignatures: params.numSignatures,
                crossbarClient: params.crossbarClient,
                payer: payer,
            }, debug);
            // Generate an OracleResponse for each oracle response in the returned report.
            const oracleResponses = report.oracle_responses.map(x => {
                // Because we only requested a single feed response, we can use the first one.
                const feedResponse = x.feed_responses[0];
                // The returned oracle_pubkey is a hex string, so we need to convert it to a PublicKey.
                const oraclePubkeyBytes = buffer_1.Buffer.from(x.oracle_pubkey, 'hex');
                const oraclePubkey = isSolana
                    ? new anchor_30_1.web3.PublicKey(oraclePubkeyBytes)
                    : anchor_30_1.web3.PublicKey.findProgramAddressSync([buffer_1.Buffer.from('Oracle'), queue.toBuffer(), oraclePubkeyBytes], params.pullFeed.program.programId)[0];
                const oracle = new oracle_js_1.Oracle(params.pullFeed.program, oraclePubkey);
                const error = feedResponse.failure_error;
                const oldDP = common_1.Big.DP;
                common_1.Big.DP = 40;
                const value = feedResponse.success_value
                    ? new common_1.Big(feedResponse.success_value).div(1e18)
                    : null;
                common_1.Big.DP = oldDP;
                return new OracleResponse(oracle, value, error);
            });
            // Find the number of successful responses.
            const numSuccesses = oracleResponses.filter(({ value }) => value).length;
            return [
                /* instructions= */ numSuccesses ? ixns : undefined,
                /* oracleResponses= */ oracleResponses,
                /* numSuccesses= */ numSuccesses,
                /* luts= */ luts,
                /* failures= */ oracleResponses.map(x => x.error),
            ];
        });
    }
    static fetchUpdateIxSvm(params, debug, payer) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const isSolana = getIsSolana(params.chain);
            const isMainnet = getIsMainnet(params.network);
            // Get the feed data for this feed.
            const feed = params.pullFeed;
            const feedData = yield feed.loadData();
            // If we are using Solana, we can use the queue that the feed is on. Otherwise, we need to
            // load the default queue for the specified network.
            const solanaQueuePubkey = isSolana
                ? feedData.queue
                : spl.getDefaultQueueAddress(isMainnet);
            if (debug)
                console.log(`Using queue ${solanaQueuePubkey.toBase58()}`);
            const solanaProgram = isSolana
                ? // If Solana, the feed's program can be used.
                    feed.program
                : // If not Solana, load a Switchboard Solana program.
                    yield (() => __awaiter(this, void 0, void 0, function* () {
                        var _a;
                        const cluster = isMainnet ? 'mainnet-beta' : 'devnet';
                        const rpc = (_a = params.solanaRpcUrl) !== null && _a !== void 0 ? _a : anchor_30_1.web3.clusterApiUrl(cluster);
                        const connection = new anchor_30_1.web3.Connection(rpc);
                        return AnchorUtils_js_1.AnchorUtils.loadProgramFromConnection(connection);
                    }))();
            const connection = feed.program.provider.connection;
            const slotHashes = (_a = params.recentSlothashes) !== null && _a !== void 0 ? _a : (yield recentSlothashes_js_1.RecentSlotHashes.fetchLatestNSlothashes(connection, 30));
            const crossbarClient = (_b = params.crossbarClient) !== null && _b !== void 0 ? _b : common_1.CrossbarClient.default();
            const jobs = yield crossbarClient
                .fetch(buffer_1.Buffer.from(feedData.feedHash).toString('hex'))
                .then(resp => resp.jobs);
            const { responses, failures } = yield queue_js_1.Queue.fetchSignatures(solanaProgram, {
                gateway: params.gateway,
                numSignatures: params.numSignatures,
                jobs: jobs,
                queue: solanaQueuePubkey,
                recentHash: slotHashes[0][1],
            });
            const oracleResponses = responses.map(resp => {
                // The returned oracle_pubkey is a hex string, so we need to convert it to a PublicKey.
                const oraclePubkeyBytes = buffer_1.Buffer.from(resp.oracle_pubkey, 'hex');
                const oraclePubkey = isSolana
                    ? new anchor_30_1.web3.PublicKey(oraclePubkeyBytes)
                    : anchor_30_1.web3.PublicKey.findProgramAddressSync([
                        buffer_1.Buffer.from('Oracle'),
                        feedData.queue.toBuffer(),
                        oraclePubkeyBytes,
                    ], params.pullFeed.program.programId)[0];
                const oracle = new oracle_js_1.Oracle(params.pullFeed.program, oraclePubkey);
                const error = resp.failure_error;
                const oldDP = common_1.Big.DP;
                common_1.Big.DP = 40;
                const value = resp.success_value
                    ? new common_1.Big(resp.success_value).div(1e18)
                    : null;
                common_1.Big.DP = oldDP;
                return new OracleResponse(oracle, value, error);
            });
            // Find the number of successful responses.
            const numSuccesses = oracleResponses.filter(({ value }) => value).length;
            if (!numSuccesses) {
                throw new Error(`PullFeed.fetchUpdateIx Failure: ${oracleResponses.map(x => x.error)}`);
            }
            if (debug)
                console.log('responses', responses);
            const submitSignaturesIx = feed.getSolanaSubmitSignaturesIx({
                resps: responses,
                // NOTE: offsets are deprecated.
                offsets: Array(responses.length).fill(0),
                slot: slotHashes[0][0],
                payer,
                chain: params.chain,
            });
            const loadLookupTables = spl.createLoadLookupTables();
            const luts = yield loadLookupTables([
                feed,
                ...oracleResponses.map(({ oracle }) => oracle),
            ]);
            return [
                [submitSignaturesIx],
                oracleResponses,
                numSuccesses,
                luts,
                failures,
            ];
        });
    }
    /**
     * Fetches updates for multiple feeds at once into a SINGLE tightly packed instruction.
     * Returns instructions that must be executed in order, with the secp256k1 verification
     * instruction placed at the front of the transaction.
     *
     * @param program - The Anchor program instance.
     * @param params_ - The parameters object.
     * @param params_.feeds - An array of PullFeed account public keys.
     * @param params_.gateway - The gateway URL to use. If not provided, the gateway is automatically fetched.
     * @param params_.recentSlothashes - The recent slothashes to use. If not provided, the latest 30 slothashes are fetched.
     * @param params_.numSignatures - The number of signatures to fetch.
     * @param params_.crossbarClient - Optionally specify the CrossbarClient to use.
     * @param params_.payer - The payer of the transaction. If not provided, the payer is automatically fetched.
     * @param debug - A boolean flag to enable or disable debug mode. Defaults to `false`.
     * @returns A promise that resolves to a tuple containing:
     * - An array of transaction instructions that must be executed in order:
     *   [0] = secp256k1 program verification instruction
     *   [1] = feed update instruction
     * - An array of `AddressLookupTableAccount` to use.
     * - The raw response data.
     */
    static fetchUpdateManyIx(program_1, params_1) {
        return __awaiter(this, arguments, void 0, function* (program, params, debug = false) {
            var _a, _b, _c, _d;
            const isSolana = getIsSolana(params.chain);
            const isMainnet = getIsMainnet(params.network);
            const feeds = common_1.NonEmptyArrayUtils.validate(params.feeds);
            const crossbarClient = (_a = params.crossbarClient) !== null && _a !== void 0 ? _a : common_1.CrossbarClient.default();
            // Validate that (1) all of the feeds specified exist and (2) all of the feeds are on the same
            // queue. Assuming that these conditions are met, we can map the feeds' data to their configs to
            // request signatures from a gateway.
            const feedDatas = yield PullFeed.loadMany(program, feeds);
            const queue = (_c = (_b = feedDatas[0]) === null || _b === void 0 ? void 0 : _b.queue) !== null && _c !== void 0 ? _c : anchor_30_1.web3.PublicKey.default;
            const feedConfigs = [];
            for (let idx = 0; idx < feedDatas.length; idx++) {
                const data = feedDatas[idx];
                if (!data) {
                    const pubkey = feeds[idx];
                    throw new Error(`No feed found at ${pubkey.toBase58()}}`);
                }
                else if (!queue.equals(data.queue)) {
                    throw new Error('All feeds must be on the same queue');
                }
                feedConfigs.push({
                    maxVariance: data.maxVariance.toNumber() / 1e9,
                    minResponses: data.minResponses,
                    jobs: yield crossbarClient
                        .fetch(buffer_1.Buffer.from(data.feedHash).toString('hex'))
                        .then(resp => resp.jobs),
                });
            }
            // If we are using Solana, we can use the queue that the feeds are on. Otherwise, we need to
            // load the default queue for the specified network.
            const solanaQueue = isSolana
                ? queue
                : spl.getDefaultQueueAddress(isMainnet);
            if (debug)
                console.log(`Using queue ${solanaQueue.toBase58()}`);
            const connection = program.provider.connection;
            const slotHashes = (_d = params.recentSlothashes) !== null && _d !== void 0 ? _d : (yield recentSlothashes_js_1.RecentSlotHashes.fetchLatestNSlothashes(connection, 30));
            const response = yield queue_js_1.Queue.fetchSignaturesConsensus(
            /* program= */ program, 
            /* params= */ {
                queue: solanaQueue,
                gateway: params.gateway,
                recentHash: slotHashes[0][1],
                feedConfigs,
                numSignatures: params.numSignatures,
            });
            const secpSignatures = response.oracle_responses.map(oracleResponse => {
                return {
                    ethAddress: buffer_1.Buffer.from(oracleResponse.eth_address, 'hex'),
                    signature: buffer_1.Buffer.from(oracleResponse.signature, 'base64'),
                    message: buffer_1.Buffer.from(oracleResponse.checksum, 'base64'),
                    recoveryId: oracleResponse.recovery_id,
                };
            });
            const secpInstruction = Secp256k1InstructionUtils_js_1.Secp256k1InstructionUtils.buildSecp256k1Instruction(secpSignatures, 0);
            // Prepare the instruction data for the `pullFeedSubmitResponseManySecp` instruction.
            const instructionData = {
                slot: new anchor_30_1.BN(slotHashes[0][0]),
                values: response.median_responses.map(({ value }) => new anchor_30_1.BN(value)),
            };
            // Prepare the accounts for the `pullFeedSubmitResponseManySecp` instruction.
            const accounts = {
                queue: queue,
                programState: state_js_1.State.keyFromSeed(program),
                recentSlothashes: constants_js_1.SPL_SYSVAR_SLOT_HASHES_ID,
                payer: PullFeed.getPayer(program, params.payer),
                systemProgram: anchor_30_1.web3.SystemProgram.programId,
                rewardVault: spl.getAssociatedTokenAddressSync(constants_js_1.SOL_NATIVE_MINT, queue, !isSolana // TODO: Review this.
                ),
                tokenProgram: constants_js_1.SPL_TOKEN_PROGRAM_ID,
                tokenMint: constants_js_1.SOL_NATIVE_MINT,
                ixSysvar: constants_js_1.SPL_SYSVAR_INSTRUCTIONS_ID,
            };
            //
            // Prepare the remaining accounts for the `pullFeedSubmitResponseManySecp` instruction.
            //
            // We only want to include feeds that have succcessful responses returned.
            const feedPubkeys = response.median_responses.map(median_response => {
                // For each successful 'median' response, locate a feed that has the same corresponding feed hash.
                const feedIndex = feedDatas.findIndex(data => {
                    const feedHashHex = buffer_1.Buffer.from(data.feedHash).toString('hex');
                    return feedHashHex === median_response.feed_hash;
                });
                if (feedIndex >= 0)
                    return feeds[feedIndex];
                if (debug) {
                    console.warn(`Feed not found for hash: ${median_response.feed_hash}`);
                }
                return anchor_30_1.web3.PublicKey.default;
            });
            // For each oracle response, create the oracle and oracle stats accounts.
            const oraclePubkeys = response.oracle_responses.map(response => {
                return new anchor_30_1.web3.PublicKey(buffer_1.Buffer.from(response.oracle_pubkey, 'hex'));
            });
            const oracleFeedStatsPubkeys = oraclePubkeys.map(oracle => anchor_30_1.web3.PublicKey.findProgramAddressSync([buffer_1.Buffer.from('OracleStats'), oracle.toBuffer()], program.programId)[0]);
            const remainingAccounts = [
                ...feedPubkeys.map(feedPubkey => ({
                    pubkey: feedPubkey,
                    isSigner: false,
                    isWritable: true,
                })),
                ...oraclePubkeys.map(oraclePubkey => ({
                    pubkey: oraclePubkey,
                    isSigner: false,
                    isWritable: false,
                })),
                ...oracleFeedStatsPubkeys.map(oracleFeedStatsPubkey => ({
                    pubkey: oracleFeedStatsPubkey,
                    isSigner: false,
                    isWritable: true,
                })),
            ];
            const submitResponseIx = program.instruction.pullFeedSubmitResponseConsensus(instructionData, {
                accounts,
                remainingAccounts,
            });
            // Load the lookup tables for the feeds and oracles.
            const loadLookupTables = spl.createLoadLookupTables();
            const luts = yield loadLookupTables([
                ...feedPubkeys.map(pubkey => new PullFeed(program, pubkey)),
                ...oraclePubkeys.map(pubkey => new oracle_js_1.Oracle(program, pubkey)),
            ]);
            return [[secpInstruction, submitResponseIx], luts, response];
        });
    }
    static fetchUpdateManyLightIx(program_1, params_1) {
        return __awaiter(this, arguments, void 0, function* (program, params, debug = false) {
            var _a, _b, _c, _d;
            const isSolana = getIsSolana(params.chain);
            const isMainnet = getIsMainnet(params.network);
            const feeds = common_1.NonEmptyArrayUtils.validate(params.feeds);
            const crossbarClient = (_a = params.crossbarClient) !== null && _a !== void 0 ? _a : common_1.CrossbarClient.default();
            // Validate that (1) all of the feeds specified exist and (2) all of the feeds are on the same
            // queue. Assuming that these conditions are met, we can map the feeds' data to their configs to
            // request signatures from a gateway.
            const feedDatas = yield PullFeed.loadMany(program, feeds);
            const queue = (_c = (_b = feedDatas[0]) === null || _b === void 0 ? void 0 : _b.queue) !== null && _c !== void 0 ? _c : anchor_30_1.web3.PublicKey.default;
            const feedConfigs = [];
            for (let idx = 0; idx < feedDatas.length; idx++) {
                const data = feedDatas[idx];
                if (!data) {
                    const pubkey = feeds[idx];
                    throw new Error(`No feed found at ${pubkey.toBase58()}}`);
                }
                else if (!queue.equals(data.queue)) {
                    throw new Error('All feeds must be on the same queue');
                }
                feedConfigs.push({
                    maxVariance: data.maxVariance.toNumber() / 1e9,
                    minResponses: data.minResponses,
                    jobs: yield crossbarClient
                        .fetch(buffer_1.Buffer.from(data.feedHash).toString('hex'))
                        .then(resp => resp.jobs),
                });
            }
            // If we are using Solana, we can use the queue that the feeds are on. Otherwise, we need to
            // load the default queue for the specified network.
            const solanaQueue = isSolana
                ? queue
                : spl.getDefaultQueueAddress(isMainnet);
            if (debug)
                console.log(`Using queue ${solanaQueue.toBase58()}`);
            const connection = program.provider.connection;
            const slotHashes = (_d = params.recentSlothashes) !== null && _d !== void 0 ? _d : (yield recentSlothashes_js_1.RecentSlotHashes.fetchLatestNSlothashes(connection, 30));
            const response = yield queue_js_1.Queue.fetchSignaturesConsensus(
            /* program= */ program, 
            /* params= */ {
                queue: solanaQueue,
                gateway: params.gateway,
                recentHash: slotHashes[0][1],
                feedConfigs,
                numSignatures: params.numSignatures,
            });
            const secpSignatures = response.oracle_responses.map(oracleResponse => {
                return {
                    ethAddress: buffer_1.Buffer.from(oracleResponse.eth_address, 'hex'),
                    signature: buffer_1.Buffer.from(oracleResponse.signature, 'base64'),
                    message: buffer_1.Buffer.from(oracleResponse.checksum, 'base64'),
                    recoveryId: oracleResponse.recovery_id,
                };
            });
            const secpInstruction = Secp256k1InstructionUtils_js_1.Secp256k1InstructionUtils.buildSecp256k1Instruction(secpSignatures, 0);
            // Prepare the instruction data for the `pullFeedSubmitResponseManySecp` instruction.
            const instructionData = {
                slot: new anchor_30_1.BN(slotHashes[0][0]),
                values: response.median_responses.map(({ value }) => new anchor_30_1.BN(value)),
            };
            // Prepare the accounts for the `pullFeedSubmitResponseManySecp` instruction.
            const accounts = {
                queue: queue,
                programState: state_js_1.State.keyFromSeed(program),
                recentSlothashes: constants_js_1.SPL_SYSVAR_SLOT_HASHES_ID,
                payer: PullFeed.getPayer(program, params.payer),
                systemProgram: anchor_30_1.web3.SystemProgram.programId,
                rewardVault: spl.getAssociatedTokenAddressSync(constants_js_1.SOL_NATIVE_MINT, queue, !isSolana // TODO: Review this.
                ),
                tokenProgram: constants_js_1.SPL_TOKEN_PROGRAM_ID,
                tokenMint: constants_js_1.SOL_NATIVE_MINT,
                ixSysvar: constants_js_1.SPL_SYSVAR_INSTRUCTIONS_ID,
            };
            //
            // Prepare the remaining accounts for the `pullFeedSubmitResponseManySecp` instruction.
            //
            // We only want to include feeds that have succcessful responses returned.
            const feedPubkeys = response.median_responses.map(median_response => {
                // For each successful 'median' response, locate a feed that has the same corresponding feed hash.
                const feedIndex = feedDatas.findIndex(data => {
                    const feedHashHex = buffer_1.Buffer.from(data.feedHash).toString('hex');
                    return feedHashHex === median_response.feed_hash;
                });
                if (feedIndex >= 0)
                    return feeds[feedIndex];
                if (debug) {
                    console.warn(`Feed not found for hash: ${median_response.feed_hash}`);
                }
                return anchor_30_1.web3.PublicKey.default;
            });
            // For each oracle response, create the oracle and oracle stats accounts.
            const oraclePubkeys = response.oracle_responses.map(response => {
                return new anchor_30_1.web3.PublicKey(buffer_1.Buffer.from(response.oracle_pubkey, 'hex'));
            });
            const remainingAccounts = [
                ...feedPubkeys.map(feedPubkey => ({
                    pubkey: feedPubkey,
                    isSigner: false,
                    isWritable: true,
                })),
                ...oraclePubkeys.map(oraclePubkey => ({
                    pubkey: oraclePubkey,
                    isSigner: false,
                    isWritable: false,
                })),
            ];
            const submitResponseIx = program.instruction.pullFeedSubmitResponseConsensusLight(instructionData, {
                accounts,
                remainingAccounts,
            });
            // Load the lookup tables for the feeds and oracles.
            const loadLookupTables = spl.createLoadLookupTables();
            const luts = yield loadLookupTables([
                ...feedPubkeys.map(pubkey => new PullFeed(program, pubkey)),
                ...oraclePubkeys.map(pubkey => new oracle_js_1.Oracle(program, pubkey)),
            ]);
            return [[secpInstruction, submitResponseIx], luts, response];
        });
    }
    /**
     *  Compiles a transaction instruction to submit oracle signatures for a given feed.
     *
     *  @param resps The oracle responses. This may be obtained from the `Gateway` class.
     *  @param slot The slot at which the oracles signed the feed with the current slothash.
     *  @returns A promise that resolves to the transaction instruction.
     */
    getSolanaSubmitSignaturesIx(params) {
        const program = this.program;
        const payerPublicKey = PullFeed.getPayer(program, params.payer);
        const resps = params.resps.filter(x => { var _a; return ((_a = x.signature) !== null && _a !== void 0 ? _a : '').length > 0; });
        const isSolana = getIsSolana(params.chain);
        let queue = new anchor_30_1.web3.PublicKey(buffer_1.Buffer.from(resps[0].queue_pubkey.toString(), 'hex'));
        const sourceQueueKey = new anchor_30_1.web3.PublicKey(buffer_1.Buffer.from(resps[0].queue_pubkey.toString(), 'hex'));
        let queueBump = 0;
        if (!isSolana) {
            [queue, queueBump] = anchor_30_1.web3.PublicKey.findProgramAddressSync([buffer_1.Buffer.from('Queue'), queue.toBuffer()], program.programId);
        }
        const oracles = resps.map(x => {
            const sourceOracleKey = new anchor_30_1.web3.PublicKey(buffer_1.Buffer.from(x.oracle_pubkey.toString(), 'hex'));
            if (isSolana) {
                return sourceOracleKey;
            }
            else {
                const [oraclePDA] = anchor_30_1.web3.PublicKey.findProgramAddressSync([buffer_1.Buffer.from('Oracle'), queue.toBuffer(), sourceOracleKey.toBuffer()], program.programId);
                return oraclePDA;
            }
        });
        const oracleFeedStats = oracles.map(oracle => anchor_30_1.web3.PublicKey.findProgramAddressSync([buffer_1.Buffer.from('OracleStats'), oracle.toBuffer()], program.programId)[0]);
        const submissions = resps.map((resp, idx) => ({
            value: new anchor_30_1.BN(resp.success_value.toString()),
            signature: resp.signature,
            recoveryId: resp.recovery_id,
            // NOTE: offsets aren't used in the non-solana endpoint.
            slotOffset: isSolana ? params.offsets[idx] : undefined,
        }));
        const instructionData = {
            slot: new anchor_30_1.BN(params.slot),
            submissions: submissions.map(x => (Object.assign(Object.assign({}, x), { signature: buffer_1.Buffer.from(x.signature, 'base64') }))),
            sourceQueueKey: isSolana ? undefined : sourceQueueKey,
            queueBump: isSolana ? undefined : queueBump,
        };
        const accounts = {
            feed: this.pubkey,
            queue: queue,
            programState: state_js_1.State.keyFromSeed(program),
            recentSlothashes: constants_js_1.SPL_SYSVAR_SLOT_HASHES_ID,
            payer: payerPublicKey,
            systemProgram: anchor_30_1.web3.SystemProgram.programId,
            rewardVault: spl.getAssociatedTokenAddressSync(constants_js_1.SOL_NATIVE_MINT, queue, !isSolana),
            tokenProgram: constants_js_1.SPL_TOKEN_PROGRAM_ID,
            tokenMint: constants_js_1.SOL_NATIVE_MINT,
        };
        const remainingAccounts = [
            ...oracles.map(k => ({
                pubkey: k,
                isSigner: false,
                isWritable: false,
            })),
            ...oracleFeedStats.map(k => ({
                pubkey: k,
                isSigner: false,
                isWritable: true,
            })),
        ];
        if (isSolana) {
            return program.instruction.pullFeedSubmitResponse(instructionData, {
                accounts,
                remainingAccounts,
            });
        }
        else {
            return program.instruction.pullFeedSubmitResponseSvm(instructionData, {
                accounts,
                remainingAccounts,
            });
        }
    }
    /**
     *  Checks if the pull feed account has been initialized.
     *
     *  @returns A promise that resolves to a boolean indicating if the account has been initialized.
     */
    isInitializedAsync() {
        return __awaiter(this, void 0, void 0, function* () {
            return !(yield checkNeedsInit(this.program.provider.connection, this.program.programId, this.pubkey));
        });
    }
    /**
     *  Loads the feed data for this {@linkcode PullFeed} account from on chain.
     *
     *  @returns A promise that resolves to the feed data.
     *  @throws if the feed account does not exist.
     */
    loadData() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.program.account['pullFeedAccountData'].fetch(this.pubkey);
        });
    }
    /**
     *  Loads the feed data for multiple feeds at once.
     *
     *  @param program The program instance.
     *  @param pubkeys The public keys of the feeds to load.
     *  @returns A promise that resolves to an array of feed data (or null if the feed account does not exist)
     */
    static loadMany(program, pubkeys) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield program.account['pullFeedAccountData'].fetchMultiple(pubkeys);
        });
    }
    /**
     *  Loads the feed data for this {@linkcode PullFeed} account from on chain.
     *
     *  @returns A promise that resolves to the values currently stored in the feed.
     *  @throws if the feed account does not exist.
     */
    loadValues() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.loadData();
            return PullFeed.mapFeedSubmissions(data);
        });
    }
    /**
     *  Loads the feed data for this {@linkcode PullFeed} account from on chain.
     *
     *  @param onlyAfter Call will ignore data signed before this slot.
     *  @returns A promise that resolves to the observed value as it would be
     *           seen on-chain.
     */
    loadObservedValue(onlyAfter) {
        return __awaiter(this, void 0, void 0, function* () {
            const values = yield this.loadValues();
            return toFeedValue(values, onlyAfter);
        });
    }
    /**
     * Watches for any on-chain updates to the feed data.
     *
     * @param callback The callback to call when the feed data is updated.
     * @returns A promise that resolves to a subscription ID.
     */
    subscribeToValueChanges(callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const coder = new anchor_30_1.BorshAccountsCoder(this.program.idl);
            const subscriptionId = this.program.provider.connection.onAccountChange(this.pubkey, (accountInfo) => __awaiter(this, void 0, void 0, function* () {
                const feed = coder.decode('pullFeedAccountData', accountInfo.data);
                yield callback(PullFeed.mapFeedSubmissions(feed));
            }), { commitment: 'processed' });
            return subscriptionId;
        });
    }
    static mapFeedSubmissions(data) {
        const oldDP = common_1.Big.DP;
        common_1.Big.DP = 40;
        const submissions = data.submissions
            .filter(x => !x.oracle.equals(anchor_30_1.web3.PublicKey.default))
            .map(x => ({
            value: new common_1.Big(x.value.toString()).div(1e18),
            slot: new anchor_30_1.BN(x.slot.toString()),
            oracle: new anchor_30_1.web3.PublicKey(x.oracle),
        }));
        common_1.Big.DP = oldDP;
        return submissions;
    }
    /**
     * Watches for any on-chain updates to any data feed.
     *
     * @param program The Anchor program instance.
     * @param callback The callback to call when the feed data is updated.
     * @returns A promise that resolves to a subscription ID.
     */
    static subscribeToAllUpdates(program, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const coder = new anchor_30_1.BorshAccountsCoder(program.idl);
            const subscriptionId = program.provider.connection.onProgramAccountChange(program.programId, (keyedAccountInfo, ctx) => __awaiter(this, void 0, void 0, function* () {
                const { accountId, accountInfo } = keyedAccountInfo;
                try {
                    const feed = coder.decode('pullFeedAccountData', accountInfo.data);
                    yield callback([
                        ctx.slot,
                        {
                            pubkey: accountId,
                            submissions: feed.submissions
                                .filter(x => !x.oracle.equals(anchor_30_1.web3.PublicKey.default))
                                .map(x => {
                                common_1.Big.DP = 40;
                                return {
                                    value: new common_1.Big(x.value.toString()).div(1e18),
                                    slot: new anchor_30_1.BN(x.slot.toString()),
                                    oracle: new anchor_30_1.web3.PublicKey(x.oracle),
                                };
                            }),
                        },
                    ]);
                }
                catch (e) {
                    console.log(`ParseFailure: ${e}`);
                }
            }), 'processed', [
                {
                    memcmp: {
                        bytes: 'ZoV7s83c7bd',
                        offset: 0,
                    },
                },
            ]);
            return subscriptionId;
        });
    }
    loadLookupTable() {
        return __awaiter(this, void 0, void 0, function* () {
            // If the lookup table is already loaded, return it
            if (this.lut)
                return this.lut;
            const lutKey = yield this.lookupTableKey();
            const accnt = yield this.program.provider.connection.getAddressLookupTable(lutKey);
            this.lut = accnt.value;
            return this.lut;
        });
    }
    loadHistoricalValuesCompact(data_) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = data_ !== null && data_ !== void 0 ? data_ : (yield this.loadData());
            const values = data.historicalResults
                .filter(x => x.slot.gt(new anchor_30_1.BN(0)))
                .sort((a, b) => a.slot.cmp(b.slot));
            return values;
        });
    }
}
exports.PullFeed = PullFeed;
//# sourceMappingURL=pullFeed.js.map