"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomBorshAccountsCoder = exports.CustomBorshCoder = void 0;
const buffer_1 = require("buffer");
const camelcase_1 = __importDefault(require("camelcase"));
const coder_1 = require("@coral-xyz/anchor/dist/cjs/coder");
const types_1 = require("@coral-xyz/anchor/dist/cjs/coder/borsh/types");
const discriminator_1 = require("@coral-xyz/anchor/dist/cjs/coder/borsh/discriminator");
class CustomBorshCoder {
    constructor(idl) {
        this.instruction = new coder_1.BorshInstructionCoder(idl);
        this.accounts = new CustomBorshAccountsCoder(idl);
        this.events = new coder_1.BorshEventCoder(idl);
        this.types = new types_1.BorshTypesCoder(idl);
        this.idl = idl;
    }
}
exports.CustomBorshCoder = CustomBorshCoder;
/**
 * Custom accounts coder that wraps BorshAccountsCoder to fix encode buffer sizing.
 */
class CustomBorshAccountsCoder {
    constructor(idl) {
        this.baseCoder = new coder_1.BorshAccountsCoder(idl);
        this.idl = idl;
    }
    async encode(accountName, account) {
        var _a;
        const idlAcc = (_a = this.idl.accounts) === null || _a === void 0 ? void 0 : _a.find((acc) => acc.name === accountName);
        if (!idlAcc) {
            throw new Error(`Unknown account not found in idl: ${accountName}`);
        }
        const buffer = buffer_1.Buffer.alloc(this.size(idlAcc)); // fix encode issue - use proper size instead of fixed 1000
        const layout = this.baseCoder['accountLayouts'].get(accountName);
        if (!layout) {
            throw new Error(`Unknown account: ${accountName}`);
        }
        const len = layout.encode(account, buffer);
        const accountData = buffer.slice(0, len);
        const discriminator = coder_1.BorshAccountsCoder.accountDiscriminator(accountName);
        return buffer_1.Buffer.concat([discriminator, accountData]);
    }
    // Delegate all other methods to the base coder
    decode(accountName, data) {
        return this.baseCoder.decode(accountName, data);
    }
    decodeAny(data) {
        return this.baseCoder.decodeAny(data);
    }
    decodeUnchecked(accountName, ix) {
        return this.baseCoder.decodeUnchecked(accountName, ix);
    }
    memcmp(accountName, appendData) {
        return this.baseCoder.memcmp(accountName, appendData);
    }
    size(idlAccount) {
        return this.baseCoder.size(idlAccount);
    }
    /**
     * Calculates and returns a unique 8 byte discriminator prepended to all anchor accounts.
     *
     * @param name The name of the account to calculate the discriminator.
     */
    static accountDiscriminator(name) {
        const discriminatorPreimage = `account:${(0, camelcase_1.default)(name, {
            pascalCase: true,
            preserveConsecutiveUppercase: true,
        })}`;
        return (0, discriminator_1.discriminator)(discriminatorPreimage);
    }
}
exports.CustomBorshAccountsCoder = CustomBorshAccountsCoder;
