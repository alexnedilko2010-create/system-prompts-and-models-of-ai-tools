/// <reference types="node" />
import { AccountSubscriber, DataAndSlot, DelistedMarketSetting, DriftClientAccountEvents, DriftClientAccountSubscriber, ResubOpts } from './types';
import { PerpMarketAccount, SpotMarketAccount, StateAccount } from '../types';
import { Program } from '@coral-xyz/anchor';
import StrictEventEmitter from 'strict-event-emitter-types';
import { EventEmitter } from 'events';
import { PublicKey } from '@solana/web3.js';
import { Commitment } from 'gill';
import { OracleInfo, OraclePriceData } from '../oracles/types';
import { OracleClientCache } from '../oracles/oracleClientCache';
import { WebSocketProgramAccountsSubscriberV2 } from './webSocketProgramAccountsSubscriberV2';
import { WebSocketAccountSubscriberV2 } from './webSocketAccountSubscriberV2';
export declare class WebSocketDriftClientAccountSubscriberV2 implements DriftClientAccountSubscriber {
    isSubscribed: boolean;
    program: Program;
    commitment?: Commitment;
    perpMarketIndexes: number[];
    spotMarketIndexes: number[];
    oracleInfos: OracleInfo[];
    oracleClientCache: OracleClientCache;
    resubOpts?: ResubOpts;
    shouldFindAllMarketsAndOracles: boolean;
    skipInitialData: boolean;
    eventEmitter: StrictEventEmitter<EventEmitter, DriftClientAccountEvents>;
    stateAccountSubscriber?: WebSocketAccountSubscriberV2<StateAccount>;
    perpMarketAllAccountsSubscriber: WebSocketProgramAccountsSubscriberV2<PerpMarketAccount>;
    perpMarketAccountLatestData: Map<number, DataAndSlot<PerpMarketAccount>>;
    spotMarketAllAccountsSubscriber: WebSocketProgramAccountsSubscriberV2<SpotMarketAccount>;
    spotMarketAccountLatestData: Map<number, DataAndSlot<SpotMarketAccount>>;
    perpOracleMap: Map<number, PublicKey>;
    perpOracleStringMap: Map<number, string>;
    spotOracleMap: Map<number, PublicKey>;
    spotOracleStringMap: Map<number, string>;
    oracleSubscribers: Map<string, AccountSubscriber<OraclePriceData>>;
    delistedMarketSetting: DelistedMarketSetting;
    initialPerpMarketAccountData: Map<number, PerpMarketAccount>;
    initialSpotMarketAccountData: Map<number, SpotMarketAccount>;
    initialOraclePriceData: Map<string, OraclePriceData>;
    protected isSubscribing: boolean;
    protected subscriptionPromise: Promise<boolean>;
    protected subscriptionPromiseResolver: (val: boolean) => void;
    private rpc;
    private rpcSubscriptions;
    constructor(program: Program, perpMarketIndexes: number[], spotMarketIndexes: number[], oracleInfos: OracleInfo[], shouldFindAllMarketsAndOracles: boolean, delistedMarketSetting: DelistedMarketSetting, resubOpts?: ResubOpts, commitment?: Commitment, skipInitialData?: boolean);
    subscribe(): Promise<boolean>;
    chunks: <T>(array: readonly T[], size: number) => T[][];
    fetch(): Promise<void>;
    /**
     * This is a no-op method that always returns true.
     * Unlike the previous implementation, we don't need to manually subscribe to individual perp markets
     * because we automatically receive updates for all program account changes via a single websocket subscription.
     * This means any new perp markets will automatically be included without explicit subscription.
     * @param marketIndex The perp market index to add (unused)
     * @returns Promise that resolves to true
     */
    addPerpMarket(_marketIndex: number): Promise<boolean>;
    /**
     * This is a no-op method that always returns true.
     * Unlike the previous implementation, we don't need to manually subscribe to individual spot markets
     * because we automatically receive updates for all program account changes via a single websocket subscription.
     * This means any new spot markets will automatically be included without explicit subscription.
     * @param marketIndex The spot market index to add (unused)
     * @returns Promise that resolves to true
     */
    addSpotMarket(_marketIndex: number): Promise<boolean>;
    setInitialData(): Promise<void>;
    removeInitialData(): void;
    subscribeToOracles(): Promise<boolean>;
    subscribeToOracle(oracleInfo: OracleInfo): Promise<boolean>;
    unsubscribeFromMarketAccounts(): Promise<void>;
    unsubscribeFromSpotMarketAccounts(): Promise<void>;
    unsubscribeFromOracles(): Promise<void>;
    unsubscribe(): Promise<void>;
    addOracle(oracleInfo: OracleInfo): Promise<boolean>;
    setPerpOracleMap(): Promise<void>;
    setSpotOracleMap(): Promise<void>;
    handleDelistedMarketOracles(): Promise<void>;
    assertIsSubscribed(): void;
    getStateAccountAndSlot(): DataAndSlot<StateAccount>;
    getMarketAccountAndSlot(marketIndex: number): DataAndSlot<PerpMarketAccount> | undefined;
    getMarketAccountsAndSlots(): DataAndSlot<PerpMarketAccount>[];
    getSpotMarketAccountAndSlot(marketIndex: number): DataAndSlot<SpotMarketAccount> | undefined;
    getSpotMarketAccountsAndSlots(): DataAndSlot<SpotMarketAccount>[];
    getOraclePriceDataAndSlot(oracleId: string): DataAndSlot<OraclePriceData> | undefined;
    getOraclePriceDataAndSlotForPerpMarket(marketIndex: number): DataAndSlot<OraclePriceData> | undefined;
    getOraclePriceDataAndSlotForSpotMarket(marketIndex: number): DataAndSlot<OraclePriceData> | undefined;
}
//# sourceMappingURL=webSocketDriftClientAccountSubscriberV2.d.ts.map