import { DriftClient } from '../driftClient';
import { DriftEnv } from '../config';
import { OptionalOrderParams, SignedMsgOrderParamsDelegateMessage, SignedMsgOrderParamsMessage, UserAccount } from '../types';
import { Keypair, TransactionInstruction } from '@solana/web3.js';
export interface AccountGetter {
    mustGetUserAccount(publicKey: string): Promise<UserAccount>;
}
export type SwiftOrderSubscriberConfig = {
    driftClient: DriftClient;
    userAccountGetter?: AccountGetter;
    driftEnv: DriftEnv;
    endpoint?: string;
    marketIndexes: number[];
    /**
        In the future, this will be used for verifying $DRIFT stake as we add
        authentication for delegate signers
        For now, pass a new keypair or a keypair to an empty wallet
    */
    keypair: Keypair;
};
/**
 * Swift order message received from WebSocket
 */
export interface SwiftOrderMessage {
    /** Hex string of the order message */
    order_message: string;
    /** Base58 string of taker authority */
    taker_authority: string;
    /** Base58 string of signing authority */
    signing_authority: string;
    /** Base64 string containing the order signature */
    order_signature: string;
    /** Swift order UUID */
    uuid: string;
    /** Whether the order auction params are likely to be sanitized on submission to program */
    will_sanitize?: boolean;
    /** Base64 string of a prerequisite deposit tx. The swift order_message should be bundled
     * after the deposit when present  */
    depositTx?: string;
    /** order market index */
    market_index: number;
    /** order timestamp in unix ms */
    ts: number;
}
export declare class SwiftOrderSubscriber {
    private config;
    private heartbeatTimeout;
    private readonly heartbeatIntervalMs;
    private ws;
    private driftClient;
    userAccountGetter?: AccountGetter;
    onOrder: (orderMessageRaw: SwiftOrderMessage, signedMessage: SignedMsgOrderParamsMessage | SignedMsgOrderParamsDelegateMessage, isDelegateSigner?: boolean) => Promise<void>;
    subscribed: boolean;
    constructor(config: SwiftOrderSubscriberConfig);
    unsubscribe(): void;
    getSymbolForMarketIndex(marketIndex: number): string;
    generateChallengeResponse(nonce: string): string;
    handleAuthMessage(message: any): void;
    subscribe(onOrder: (orderMessageRaw: SwiftOrderMessage, signedMessage: SignedMsgOrderParamsMessage | SignedMsgOrderParamsDelegateMessage, isDelegateSigner?: boolean) => Promise<void>, acceptSanitized?: boolean, acceptDepositTrade?: boolean): Promise<void>;
    getPlaceAndMakeSignedMsgOrderIxs(orderMessageRaw: SwiftOrderMessage, signedMsgOrderParamsMessage: SignedMsgOrderParamsMessage | SignedMsgOrderParamsDelegateMessage, makerOrderParams: OptionalOrderParams): Promise<TransactionInstruction[]>;
    private startHeartbeatTimer;
    private reconnect;
}
