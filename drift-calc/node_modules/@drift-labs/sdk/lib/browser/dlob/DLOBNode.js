"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNode = exports.SignedMsgOrderNode = exports.TriggerOrderNode = exports.MarketOrderNode = exports.FloatingLimitOrderNode = exports.RestingLimitOrderNode = exports.TakingLimitOrderNode = exports.OrderNode = void 0;
const anchor_1 = require("@coral-xyz/anchor");
const numericConstants_1 = require("../constants/numericConstants");
const orders_1 = require("../math/orders");
const types_1 = require("../types");
const conversion_1 = require("../math/conversion");
const NodeList_1 = require("./NodeList");
class OrderNode {
    constructor(order, userAccount, isProtectedMaker, protectedMakerParams, baseAssetAmount, isSignedMsg = false) {
        this.haveFilled = false;
        this.haveTrigger = false;
        // Copy the order over to the node
        this.order = { ...order };
        this.userAccount = userAccount;
        this.sortValue = this.getSortValue(order);
        this.isProtectedMaker = isProtectedMaker;
        this.protectedMakerParams = protectedMakerParams;
        this.baseAssetAmount = baseAssetAmount !== null && baseAssetAmount !== void 0 ? baseAssetAmount : order.baseAssetAmount;
        this.isSignedMsg = isSignedMsg;
    }
    getLabel() {
        let msg = `Order ${(0, NodeList_1.getOrderSignature)(this.order.orderId, this.userAccount)}`;
        msg += ` ${(0, types_1.isVariant)(this.order.direction, 'long') ? 'LONG' : 'SHORT'} `;
        msg += `${(0, conversion_1.convertToNumber)(this.order.baseAssetAmount, numericConstants_1.AMM_RESERVE_PRECISION).toFixed(3)}`;
        if (this.order.price.gt(numericConstants_1.ZERO)) {
            msg += ` @ ${(0, conversion_1.convertToNumber)(this.order.price, numericConstants_1.PRICE_PRECISION).toFixed(3)}`;
        }
        if (this.order.triggerPrice.gt(numericConstants_1.ZERO)) {
            msg += ` ${(0, types_1.isVariant)(this.order.triggerCondition, 'below') ? 'BELOW' : 'ABOVE'}`;
            msg += ` ${(0, conversion_1.convertToNumber)(this.order.triggerPrice, numericConstants_1.PRICE_PRECISION).toFixed(3)}`;
        }
        return msg;
    }
    getPrice(oraclePriceData, slot) {
        return (0, orders_1.getLimitPrice)(this.order, oraclePriceData, slot, undefined, this.isProtectedMaker ? this.protectedMakerParams : undefined);
    }
    isBaseFilled() {
        return this.order.baseAssetAmountFilled.eq(this.order.baseAssetAmount);
    }
    isVammNode() {
        return false;
    }
}
exports.OrderNode = OrderNode;
class TakingLimitOrderNode extends OrderNode {
    getSortValue(order) {
        return order.slot;
    }
}
exports.TakingLimitOrderNode = TakingLimitOrderNode;
class RestingLimitOrderNode extends OrderNode {
    getSortValue(order) {
        let sortValue = order.price;
        if (this.protectedMakerParams && this.isProtectedMaker) {
            const offset = sortValue.divn(1000);
            if ((0, types_1.isVariant)(order.direction, 'long')) {
                sortValue = sortValue.sub(offset);
            }
            else {
                sortValue = sortValue.add(offset);
            }
        }
        return sortValue;
    }
}
exports.RestingLimitOrderNode = RestingLimitOrderNode;
class FloatingLimitOrderNode extends OrderNode {
    getSortValue(order) {
        return new anchor_1.BN(order.oraclePriceOffset);
    }
}
exports.FloatingLimitOrderNode = FloatingLimitOrderNode;
class MarketOrderNode extends OrderNode {
    getSortValue(order) {
        return order.slot;
    }
}
exports.MarketOrderNode = MarketOrderNode;
class TriggerOrderNode extends OrderNode {
    getSortValue(order) {
        return order.triggerPrice;
    }
}
exports.TriggerOrderNode = TriggerOrderNode;
// We'll use the signedMsg uuid for the order id since it's not yet on-chain
class SignedMsgOrderNode extends OrderNode {
    constructor(order, userAccount, baseAssetAmount) {
        super(order, userAccount, false, undefined, baseAssetAmount, true);
    }
    getSortValue(order) {
        return order.slot;
    }
}
exports.SignedMsgOrderNode = SignedMsgOrderNode;
function createNode(nodeType, order, userAccount, isProtectedMaker, protectedMakerParams, baseAssetAmount) {
    switch (nodeType) {
        case 'floatingLimit':
            return new FloatingLimitOrderNode(order, userAccount, isProtectedMaker, protectedMakerParams, baseAssetAmount);
        case 'protectedFloatingLimit':
            return new FloatingLimitOrderNode(order, userAccount, isProtectedMaker, protectedMakerParams, baseAssetAmount);
        case 'restingLimit':
            return new RestingLimitOrderNode(order, userAccount, isProtectedMaker, protectedMakerParams, baseAssetAmount);
        case 'takingLimit':
            return new TakingLimitOrderNode(order, userAccount, isProtectedMaker, protectedMakerParams, baseAssetAmount);
        case 'market':
            return new MarketOrderNode(order, userAccount, isProtectedMaker, undefined, baseAssetAmount);
        case 'trigger':
            return new TriggerOrderNode(order, userAccount, isProtectedMaker, undefined, baseAssetAmount);
        case 'signedMsg':
            return new SignedMsgOrderNode(order, userAccount, baseAssetAmount);
        default:
            throw Error(`Unknown DLOBNode type ${nodeType}`);
    }
}
exports.createNode = createNode;
